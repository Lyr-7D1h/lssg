use chrono::prelude::{DateTime, Utc};
use std::{collections::HashMap, error::Error, fmt::Display};

use crate::{
    parser::lexer::Token,
    sitemap::{NodeType, SiteMap},
    LssgError,
};

const WATERMARK: &'static str = r#"<footer id="watermark">Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a></footer>"#;

#[derive(Debug, Clone)]
pub enum Rel {
    Stylesheet,
    Icon,
}
impl TryFrom<&String> for Rel {
    type Error = Box<dyn Error>;

    fn try_from(value: &String) -> Result<Self, Self::Error> {
        match &value[..] {
            "stylesheet" => Ok(Rel::Stylesheet),
            _ => Err(format!("Invalid rel value given {value}").into()),
        }
    }
}
impl Display for Rel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Rel::Stylesheet => f.write_str("stylesheet"),
            Rel::Icon => f.write_str("icon"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct HtmlLink {
    pub rel: Rel,
    pub href: String,
}

#[derive(Debug, Clone)]
pub struct Meta {
    pub name: String,
    pub content: String,
}

#[derive(Debug, Clone)]
pub struct HtmlRenderOptions {
    pub links: Vec<HtmlLink>,
    // Id to favicon resource
    pub favicon: Option<usize>,
    pub title: String,
    pub meta: Vec<Meta>,
    pub language: String,
}

pub struct HtmlRenderer<'n> {
    site_map: &'n SiteMap,
}

impl<'n> HtmlRenderer<'n> {
    pub fn new(site_map: &'n SiteMap) -> HtmlRenderer<'n> {
        HtmlRenderer { site_map }
    }

    fn render_body_content(tokens: &Vec<Token>, options: &mut HtmlRenderOptions) -> String {
        let mut body_content = String::new();
        for t in tokens.into_iter() {
            let html = match t {
                Token::Heading {
                    depth,
                    text: _,
                    tokens,
                } => format!(
                    "<h{depth}>{}</h{depth}>",
                    Self::render_body_content(tokens, options)
                ),
                Token::Paragraph { tokens } => {
                    format!("<p>{}</p>", Self::render_body_content(tokens, options))
                }
                Token::Bold { text } => format!("<b>{text}</b>"),
                Token::Italic { text } => format!("<i>{text}</i>"),
                Token::Code { language: _, code } => format!("<code>{code}</code>"),
                Token::Space { raw: _ } => format!(""),
                Token::Link { text, href } => {
                    if href.starts_with("http") || href.starts_with("mailto:") {
                        // external link
                        format!(
                            r#"<a href="{href}">{text} <i class="fas fa-external-link-alt" style="font-size: 0.8em"></i></a>"#
                        ) // FIXME add font awesome as default included
                    } else {
                        // internal link
                        format!(r#"<a href="{href}">{text}</a>"#)
                    }
                }
                Token::Text { text } => text.clone(),
                Token::Html {
                    kind,
                    attributes,
                    tokens,
                } => match kind.as_str() {
                    "nav" if attributes.contains_key("links") => {
                        let blocks = tokens
                            .into_iter()
                            .map(|t| match t {
                                Token::Link { text, href } => {
                                    format!(r#"<a href={href}><div class="card">{text}</div></a>"#)
                                }
                                _ => "".into(),
                            })
                            .collect::<Vec<String>>()
                            .join("");
                        format!(r#"<nav class="links">{blocks}</nav>"#)
                    }
                    _ => {
                        let attributes = attributes
                            .into_iter()
                            .map(|(k, v)| format!("{k}='{v}'"))
                            .collect::<Vec<String>>()
                            .join(" ");

                        let spacing = if attributes.len() > 0 {
                            String::from(" ")
                        } else {
                            String::new()
                        };

                        format!(
                            "<{kind}{spacing}{}>{}</{kind}>",
                            attributes,
                            Self::render_body_content(tokens, options)
                        )
                    }
                },
                Token::Comment { .. } => continue,
                Token::EOF => continue,
            };
            body_content.push_str(&html);
        }
        body_content
    }

    /// Transform tokens into a html page
    pub fn render(&self, id: usize, mut options: HtmlRenderOptions) -> Result<String, LssgError> {
        let node = self.site_map.get(id)?;
        let (mut tokens, input) = match &node.node_type {
            NodeType::Page { tokens, input, .. } => (tokens.clone(), input),
            _ => return Err(LssgError::render("Invalid node type given")),
        };

        let metadata = if let Some(Token::Comment { text: _, map }) = tokens.first() {
            map.clone()
        } else {
            HashMap::new()
        };

        let breadcrumbs = if id == self.site_map.root() || metadata.contains_key("nocrumb") {
            "".into()
        } else {
            let mut breadcrumbs = vec![];
            let mut cur = node.parent;
            while let Some(n) = cur {
                let node = self.site_map.get(n)?.parent;
                breadcrumbs.push(format!(
                    r#"<a href="{}">{}</a>"#,
                    self.site_map.rel_path(id, n),
                    self.site_map.get(n)?.name
                ));
                cur = node;
            }
            breadcrumbs.reverse();
            let crumbs = breadcrumbs.join("/") + "/";
            format!(r#"<nav class="breadcrumbs">{crumbs}</nav>"#)
        };

        if metadata.contains_key("post") {
            if let Some(Token::Heading { depth: 1, .. }) = tokens.get(2) {
                if let Ok(m) = input.metadata() {
                    if let Ok(date) = m.modified() {
                        let date: DateTime<Utc> = date.into();
                        let date = date.format("Updated on %B %d, %Y").to_string();
                        tokens.insert(
                            3,
                            Token::Html {
                                kind: "div".into(),
                                attributes: HashMap::from([(
                                    "class".into(),
                                    "post-updated-on".into(),
                                )]),
                                tokens: vec![Token::Text { text: date }],
                            },
                        )
                    }
                }
            }
        }

        let mut body_content = Self::render_body_content(&tokens, &mut options);
        if metadata.contains_key("post") {
            body_content = format!(r#"<div class="post">{body_content}</div>"#);
        }

        let body = format!(
            r#"<body><div id="content">{breadcrumbs}{body_content}</div>{WATERMARK}</body>"#
        );

        let links = options
            .links
            .iter()
            .map(|l| format!(r#"<link rel="{}" href="{}">"#, l.rel.to_string(), l.href))
            .reduce(|a, l| a + &l)
            .unwrap_or(String::new());
        let title = format!("<title>{}</title>", options.title);
        let favicon = if let Some(favicon_id) = options.favicon {
            format!(
                r#"<link rel="icon" type="image/x-icon" href="{}">"#,
                self.site_map.rel_path(id, favicon_id)
            )
        } else {
            "".into()
        };
        let head = format!(
            r#"<head>{title}<meta name="viewport" content="width=device-width, initial-scale=1" /><meta charset="utf-8" />{favicon}{links}</head>"#
        );

        let lang = options.language;
        return Ok(format!(
            r#"<!DOCTYPE html><html lang="{lang}">{head}{body}</html>"#
        ));
    }
}
