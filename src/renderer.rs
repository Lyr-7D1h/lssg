use std::{error::Error, fmt::Display};

use crate::parser::lexer::Token;

const WATERMARK: &'static str = r#"<p style="padding: 0; width: 100%; position: fixed; bottom: 0; text-align: center; ">Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a></p>"#;

#[derive(Debug, Clone)]
pub enum Rel {
    Stylesheet,
    Icon,
}
impl TryFrom<&String> for Rel {
    type Error = Box<dyn Error>;

    fn try_from(value: &String) -> Result<Self, Self::Error> {
        match &value[..] {
            "stylesheet" => Ok(Rel::Stylesheet),
            _ => Err(format!("Invalid rel value given {value}").into()),
        }
    }
}
impl Display for Rel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Rel::Stylesheet => f.write_str("stylesheet"),
            Rel::Icon => f.write_str("icon"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct HtmlLink {
    pub rel: Rel,
    pub href: String,
}

#[derive(Debug, Clone)]
pub struct Meta {
    pub name: String,
    pub content: String,
}

#[derive(Debug, Clone)]
pub struct HtmlDocumentRenderOptions {
    pub links: Vec<HtmlLink>,
    pub title: String,
    pub meta: Vec<Meta>,
    pub language: String,
}

pub struct HtmlDocument {}

impl HtmlDocument {
    fn render_body_content(tokens: &Vec<Token>, options: &mut HtmlDocumentRenderOptions) -> String {
        let mut body_content = String::new();
        for t in tokens.into_iter() {
            let html = match t {
                Token::Heading {
                    depth,
                    text,
                    tokens,
                } => format!(
                    "<h{depth}>{}</h{depth}>",
                    Self::render_body_content(tokens, options)
                ),
                Token::Paragraph { tokens } => {
                    format!("<p>{}</p>", Self::render_body_content(tokens, options))
                }
                Token::Bold { text } => format!("<b>{text}</b>"),
                Token::Italic { text } => format!("<i>{text}</i>"),
                Token::Code { language, code } => format!("<code>{code}</code>"),
                Token::Space { raw } => format!("<br />"),
                Token::Link { text, href } => format!(r#"<a href="{href}">{text}</a>"#),
                Token::Text { text } => text.clone(),
                Token::Html {
                    kind,
                    attributes,
                    tokens,
                } => {
                    let attributes = attributes
                        .into_iter()
                        .map(|(k, v)| format!("{k}='{v}'"))
                        .collect::<Vec<String>>()
                        .join(" ");

                    let spacing = if attributes.len() > 0 {
                        String::from(" ")
                    } else {
                        String::new()
                    };

                    format!(
                        "<{kind}{spacing}{}>{}</{kind}>",
                        attributes,
                        Self::render_body_content(tokens, options)
                    )
                }
                Token::EOF => continue,
            };
            body_content.push_str(&html);
        }
        body_content
    }

    /// Transform tokens into a html page
    pub fn render(tokens: &Vec<Token>, mut options: HtmlDocumentRenderOptions) -> String {
        let body_content = Self::render_body_content(tokens, &mut options);
        let body = format!("<body>{body_content}{WATERMARK}</body>");

        let links = options
            .links
            .iter()
            .map(|l| format!(r#"<link rel="{}" href="{}">"#, l.rel.to_string(), l.href))
            .reduce(|a, l| a + &l)
            .unwrap_or(String::new());
        let title = format!("<title>{}</title>", options.title);
        let head = format!("<head>{title}{links}</head>");

        let lang = options.language;
        return format!(r#"<!DOCTYPE html><html lang="{lang}">{head}{body}</html>"#);
    }
}
