pub mod blog_module;

use std::{any::Any, collections::HashMap, error::Error, fmt::Display, fs::File, path::PathBuf};

use crate::{
    domtree::{self, to_attributes, DomNode, DomNodeKind, DomTree},
    parser::lexer::Token,
    sitetree::{SiteNode, SiteNodeKind, SiteTree},
    LssgError,
};

const WATERMARK: &'static str = r#"<footer id="watermark">Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a></footer>"#;

#[derive(Debug, Clone)]
pub enum Rel {
    Stylesheet,
    Icon,
}
impl TryFrom<&String> for Rel {
    type Error = Box<dyn Error>;

    fn try_from(value: &String) -> Result<Self, Self::Error> {
        match &value[..] {
            "stylesheet" => Ok(Rel::Stylesheet),
            _ => Err(format!("Invalid rel value given {value}").into()),
        }
    }
}
impl Display for Rel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            Rel::Stylesheet => f.write_str("stylesheet"),
            Rel::Icon => f.write_str("icon"),
        }
    }
}

#[derive(Debug, Clone)]
pub struct HtmlLink {
    pub rel: Rel,
    pub href: String,
}

#[derive(Debug, Clone)]
pub struct Meta {
    pub name: String,
    pub content: String,
}

#[derive(Debug, Clone)]
pub struct HtmlRenderOptions {
    pub links: Vec<HtmlLink>,
    // Id to favicon resource
    pub favicon: Option<usize>,
    pub title: String,
    pub meta: Vec<Meta>,
    pub language: String,
}

#[derive(Debug)]
pub struct RendererModuleProperties<'n> {
    tree: &'n mut DomTree,
    site_tree: &'n SiteTree,
    site_id: usize,
    tokens: &'n Vec<Token>,
}

pub trait RendererModule {
    /// Modify DomTree on init
    fn init(
        &mut self,
        tree: &mut DomTree,
        site_tree: &SiteTree,
        site_id: usize,
        tokens: &Vec<Token>,
    );

    /// Render a token before default token renderer returns true if it parsed this token otherwise false
    fn body<'n>(
        &mut self,
        tree: &mut DomTree,
        site_tree: &SiteTree,
        site_id: usize,
        tokens: &Vec<Token>,
        token: Token,
        parent_dom_id: usize,
    ) -> bool;
}

pub struct HtmlRenderer<'n> {
    site_tree: &'n SiteTree,
    render_modules: Vec<Box<dyn RendererModule>>,
}

impl<'n> HtmlRenderer<'n> {
    pub fn new(
        site_tree: &'n SiteTree,
        render_modules: Vec<impl RendererModule + 'static>,
    ) -> HtmlRenderer<'n> {
        let render_modules = render_modules
            .into_iter()
            .map(|module| -> Box<dyn RendererModule> { Box::new(module) })
            .collect();
        HtmlRenderer {
            site_tree,
            render_modules,
        }
    }

    fn render_body_content(&self, tokens: &Vec<Token>, tree: &mut DomTree, parent_id: usize) {
        match t {
            Token::Heading {
                depth,
                text: _,
                tokens,
            } => {
                let parent = tree.add(DomNode::element(format!("h{depth}")), parent_id);
                self.render_body_content(tokens, tree, parent);
            }
            Token::Paragraph { tokens } => {
                let parent = tree.add(DomNode::element("p"), parent_id);
                self.render_body_content(tokens, tree, parent);
            }
            Token::Bold { text } => {
                let parent = tree.add(DomNode::element("b"), parent_id);
                tree.add_text(text, parent);
            }
            Token::Italic { text } => {
                let parent = tree.add_element("i", parent_id);
                tree.add_text(text, parent);
            }
            Token::Code { code, language: _ } => {
                let parent = tree.add_element("code", parent_id);
                tree.add_text(code, parent);
            }
            Token::Space { raw: _ } => {
                tree.add_text("", parent_id);
            }
            Token::Link { text, href } => {
                if href.starts_with("http") || href.starts_with("mailto:") {
                    let parent_id = tree.add_element_with_attributes(
                        "a",
                        to_attributes([("href", href)]),
                        parent_id,
                    );
                    tree.add_text(text, parent_id);
                    tree.add_element_with_attributes(
                        "i",
                        to_attributes([
                            ("class", "fas fas-external-link-alt"),
                            ("style", "font-size: 0.8em"),
                        ]),
                        parent_id,
                    );
                } else {
                    let parent_id = tree.add_element_with_attributes(
                        "a",
                        to_attributes([("href", href)]),
                        parent_id,
                    );
                    tree.add_text(text, parent_id);
                }
            }
            Token::Text { text } => {
                tree.add_text(text, parent_id);
            }
            Token::Html {
                tag,
                attributes,
                tokens,
            } => match tag.as_str() {
                "nav" if attributes.contains_key("links") => {
                    let mut attributes = attributes.clone();
                    attributes.insert("class".into(), "links".into());
                    let parent_id = tree.add_element_with_attributes("nav", attributes, parent_id);
                    for t in tokens {
                        match t {
                            Token::Link { text, href } => {
                                let parent_id = tree.add_element_with_attributes(
                                    "a",
                                    to_attributes([("href", href)]),
                                    parent_id,
                                );
                                let parent_id = tree.add_element_with_attributes(
                                    "div",
                                    to_attributes([("class", "card")]),
                                    parent_id,
                                );
                                tree.add_text(text, parent_id);
                            }
                            _ => {}
                        }
                    }
                }
                _ => {
                    let parent_id =
                        tree.add_element_with_attributes(tag, attributes.clone(), parent_id);
                    self.render_body_content(tokens, tree, parent_id)
                }
            },
            Token::Comment { .. } => continue,
            Token::EOF => continue,
        }
    }

    /// Transform site id into a html page
    pub fn render(
        &mut self,
        site_id: usize,
        mut options: HtmlRenderOptions,
    ) -> Result<String, LssgError> {
        // get the site node
        let site_node = self.site_tree.get(site_id)?;
        let (tokens, input) = match &site_node.kind {
            SiteNodeKind::Page { tokens, input, .. } => (tokens.clone(), input),
            _ => return Err(LssgError::render("Invalid node type given")),
        };

        let mut tree = DomTree::new();

        // Add language to html tag
        let id = tree.get_elements_by_tag_name("html")[0];
        if let Some(node) = tree.get_mut(id) {
            if let DomNodeKind::Element { attributes, .. } = &mut node.kind {
                attributes.insert("lang".to_owned(), options.language);
            }
        }

        for module in &mut self.render_modules {
            module.init(&mut tree, &self.site_tree, site_id, &tokens);
        }

        // let breadcrumbs = if id == self.site_tree.root() || metadata.contains_key("nocrumb") {
        //     "".into()
        // } else {
        //     let mut breadcrumbs = vec![];
        //     let mut cur = site_node.parent;
        //     while let Some(n) = cur {
        //         let node = self.site_tree.get(n)?.parent;
        //         breadcrumbs.push(format!(
        //             r#"<a href="{}">{}</a>"#,
        //             self.site_tree.rel_path(id, n),
        //             self.site_tree.get(n)?.name
        //         ));
        //         cur = node;
        //     }
        //     breadcrumbs.reverse();
        //     let crumbs = breadcrumbs.join("/") + "/";
        //     format!(r#"<nav class="breadcrumbs">{crumbs}</nav>"#)
        // };

        // if metadata.contains_key("post") {
        //     if let Some(Token::Heading { depth: 1, .. }) = tokens.get(2) {
        //         if let Ok(m) = input.metadata() {
        //             if let Ok(date) = m.modified() {
        //                 let date: DateTime<Utc> = date.into();
        //                 let date = date.format("Updated on %B %d, %Y").to_string();
        //                 tokens.insert(
        //                     3,
        //                     Token::Html {
        //                         kind: "div".into(),
        //                         attributes: HashMap::from([(
        //                             "class".into(),
        //                             "post-updated-on".into(),
        //                         )]),
        //                         tokens: vec![Token::Text { text: date }],
        //                     },
        //                 )
        //             }
        //         }
        //     }
        // }

        let body = tree.get_elements_by_tag_name("body")[0];
        let content_id =
            tree.add_element_with_attributes("div", to_attributes([("id", "content")]), body);
        self.render_body_content(
            &mut tree,
            &self.site_tree,
            site_id,
            &tokens,
            token,
            content_id,
        );

        // if metadata.contains_key("post") {
        //     body_content = format!(r#"<div class="post">{body_content}</div>"#);
        // }

        // let body = format!(
        //     r#"<body><div id="content">{breadcrumbs}{body_content}</div>{WATERMARK}</body>"#
        // );

        let head = tree.get_elements_by_tag_name("head")[0];
        let title = tree.add(DomNode::element("title"), head);
        tree.add(DomNode::text(options.title), title);
        if let Some(favicon_id) = options.favicon {
            tree.add(
                DomNode::element_with_attributes(
                    "link",
                    to_attributes([
                        ("rel", "icon"),
                        ("type", "image/x-icon"),
                        ("href", &self.site_tree.rel_path(id, favicon_id)),
                    ]),
                ),
                head,
            );
        }
        for link in options.links {
            tree.add_element_with_attributes(
                "link",
                to_attributes([("rel", link.rel.to_string()), ("href", link.href)]),
                head,
            );
        }
        tree.add_element_with_attributes(
            "meta",
            to_attributes([
                ("name", "viewport"),
                ("content", r#"width=device-width, initial-scale=1"#),
            ]),
            head,
        );
        tree.add(
            DomNode::element_with_attributes("meta", to_attributes([("charset", "utf-8")])),
            head,
        );

        println!("{tree}");
        return Ok(tree.to_html_string());
    }
}
