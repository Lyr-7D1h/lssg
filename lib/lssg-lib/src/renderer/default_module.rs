use std::{collections::HashMap, fs::File, path::PathBuf};

use serde::{Deserialize, Serialize};
use serde_extensions::Overwrite;

use crate::{
    domtree::{to_attributes, DomNode, DomNodeKind},
    lmarkdown::{lexer::Token, parse_lmarkdown},
    lssg_error::LssgError,
    sitetree::{SiteNode, SiteNodeKind, SiteTree},
    stylesheet::Stylesheet,
    tree::BFS,
    util::filestem_from_path,
};

use super::{RenderQueue, RendererModule};

const WATERMARK: &'static str = r#"<footer id="watermark">Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a></footer>"#;

#[derive(Debug, Clone, Deserialize)]
pub struct ExternalPage {
    input: PathBuf,
    output: PathBuf,
}

#[derive(Debug, Clone, Overwrite)]
struct ResourceOptions {
    // TODO implement external pages
    pub external_pages: Vec<ExternalPage>,
    /// Add extra resources
    pub stylesheets: Vec<PathBuf>,
    pub favicon: Option<PathBuf>,
}
impl Default for ResourceOptions {
    fn default() -> Self {
        Self {
            external_pages: vec![],
            favicon: None,
            stylesheets: vec![],
        }
    }
}

#[derive(Debug, Clone, Overwrite)]
struct PageOptions {
    pub title: String,
    /// Translates to meta tags <https://www.w3schools.com/tags/tag_meta.asp>
    pub meta: HashMap<String, String>,
    /// Lang attribute ("en") <https://www.w3schools.com/tags/ref_language_codes.asp>
    pub language: String,
}
impl Default for PageOptions {
    fn default() -> Self {
        Self {
            meta: HashMap::new(),
            title: String::new(),
            language: "en".into(),
        }
    }
}

/// Implements all basic default behavior, like rendering all tokens and adding meta tags and title to head
pub struct DefaultModule {
    favicon: Option<usize>,
    stylesheet: usize,
}

impl DefaultModule {
    pub fn new() -> Self {
        Self {
            favicon: None,
            stylesheet: 0,
        }
    }
}

impl RendererModule for DefaultModule {
    fn id(&self) -> &'static str {
        return "default";
    }

    fn init(&mut self, site_tree: &mut SiteTree) -> Result<(), LssgError> {
        // get all pages with options
        let pages: Vec<(usize, ResourceOptions, PathBuf)> = BFS::new(site_tree)
            .filter_map(|id| match &site_tree[id].kind {
                SiteNodeKind::Page { tokens, input, .. } => {
                    Some((id, self.options(tokens), input.clone()))
                }
                _ => None,
            })
            .collect();

        for (id, options, input) in pages {
            let base_directory = input.parent().unwrap_or(&input);

            for p in options.stylesheets {
                let mut stylesheet = Stylesheet::new();
                stylesheet.append(&base_directory.join(&p))?;
                site_tree.add(filestem_from_path(&p)?, SiteNodeKind::Stylesheet(stylesheet), id)?;
            }

            for p in options.external_pages {
                let input = base_directory.join(&p.input);
                let file = File::open(&input)?;
                site_tree.add(
                    filestem_from_path(&input)?,
                    SiteNodeKind::Page {
                        tokens: parse_lmarkdown(file)?,
                        input,
                        keep_name: true,
                    },
                    id,
                )?;
            }

            if let Some(path) = options.favicon {
                let input = base_directory.join(&path);
                site_tree.add("favicon.ico".into(), SiteNodeKind::Resource { input }, id)?;
            }
        }

        // TODO: go through all pages and create resources when necessary

        // let mut stylesheet = if self.options.overwrite_default_stylesheet {
        //     Stylesheet::new()
        // } else {
        //     Stylesheet::default()
        // };
        // for path in self.options.stylesheets.iter() {
        //     stylesheet.append(&path)?;
        // }
        // self.stylesheet =
        //     site_tree.add_stylesheet("main.css".into(), stylesheet, site_tree.root())?;

        // self.favicon = if let Some(input) = &self.options.favicon {
        //     Some(site_tree.add(
        //         SiteNode {
        //             name: "favicon.ico".into(),
        //             parent: Some(site_tree.root()),
        //             children: vec![],
        //             kind: SiteNodeKind::Resource {
        //                 input: input.clone(),
        //             },
        //         },
        //         site_tree.root(),
        //     )?)
        // } else {
        //     None
        // };

        // if let Some(input) = &self.options.not_found_page {
        //     let file = File::open(&input)?;
        //     let _ = site_tree.add(
        //         SiteNode {
        //             name: filestem_from_path(input)?,
        //             parent: Some(site_tree.root()),
        //             children: vec![],
        //             kind: SiteNodeKind::Page {
        //                 tokens: LMarkdownParser::parse(file)?,
        //                 input: input.to_path_buf(),
        //                 keep_name: true,
        //             },
        //         },
        //         site_tree.root(),
        //     );
        // }

        Ok(())
    }

    fn render_page<'n>(
        &mut self,
        dom_tree: &mut crate::domtree::DomTree,
        context: &super::RendererModuleContext<'n>,
    ) {
        let site_id = context.site_id;
        let site_tree = context.site_tree;

        // TODO get default options of site node parent and overwrite with current one
        let options: PageOptions = context.options(self);

        // Add language to html tag
        let id = dom_tree.get_elements_by_tag_name("html")[0];
        if let Some(node) = dom_tree.get_mut(id) {
            if let DomNodeKind::Element { attributes, .. } = &mut node.kind {
                attributes.insert("lang".to_owned(), options.language.clone());
            }
        }

        // fill head
        let head = dom_tree.get_elements_by_tag_name("head")[0];
        let title = dom_tree.add(DomNode::element("title"), head);
        dom_tree.add_text(options.title.clone(), title);
        if let Some(favicon) = self.favicon {
            dom_tree.add_element_with_attributes(
                "link",
                to_attributes([
                    ("rel", "icon"),
                    ("type", "image/x-icon"),
                    ("href", &site_tree.rel_path(site_id, favicon)),
                ]),
                head,
            );
        }
        dom_tree.add_element_with_attributes(
            "link",
            to_attributes([
                ("rel", "stylesheet"),
                ("href", &site_tree.rel_path(site_id, self.stylesheet)),
            ]),
            head,
        );
        dom_tree.add_element_with_attributes(
            "meta",
            to_attributes([
                ("name", "viewport"),
                ("content", r#"width=device-width, initial-scale=1"#),
            ]),
            head,
        );
        dom_tree.add(
            DomNode::element_with_attributes("meta", to_attributes([("charset", "utf-8")])),
            head,
        );
    }

    fn render_body<'n>(
        &mut self,
        tree: &mut crate::domtree::DomTree,
        context: &super::RendererModuleContext<'n>,
        render_queue: &mut RenderQueue,
        parent_id: usize,
        token: &crate::lmarkdown::lexer::Token,
    ) -> bool {
        // TODO make work
        // let content_id =
        //     tree.add_element_with_attributes("div", to_attributes([("id", "content")]), body);
        match token {
            Token::Heading {
                depth,
                text: _,
                tokens,
            } => {
                let parent = tree.add(DomNode::element(format!("h{depth}")), parent_id);
                render_queue.push_tokens_front(tokens, parent)
            }
            Token::Paragraph { tokens } => {
                let parent = tree.add(DomNode::element("p"), parent_id);
                render_queue.push_tokens_front(tokens, parent)
            }
            Token::Bold { text } => {
                let parent = tree.add(DomNode::element("b"), parent_id);
                tree.add_text(text, parent);
            }
            Token::Italic { text } => {
                let parent = tree.add_element("i", parent_id);
                tree.add_text(text, parent);
            }
            Token::Code { code, language: _ } => {
                let parent = tree.add_element("code", parent_id);
                tree.add_text(code, parent);
            }
            Token::Space { raw: _ } => {
                tree.add_text("", parent_id);
            }
            Token::Link { text, href } => {
                if href.starts_with("http") || href.starts_with("mailto:") {
                    let parent_id = tree.add_element_with_attributes(
                        "a",
                        to_attributes([("href", href)]),
                        parent_id,
                    );
                    tree.add_text(text, parent_id);
                    // TODO seperate from font awesome
                    tree.add_element_with_attributes(
                        "i",
                        to_attributes([
                            ("class", "fas fas-external-link-alt"),
                            ("style", "font-size: 0.8em"),
                        ]),
                        parent_id,
                    );
                } else {
                    let parent_id = tree.add_element_with_attributes(
                        "a",
                        to_attributes([("href", href)]),
                        parent_id,
                    );
                    tree.add_text(text, parent_id);
                }
            }
            Token::Text { text } => {
                tree.add_text(text, parent_id);
            }
            Token::Html {
                tag,
                attributes,
                tokens,
            } => match tag.as_str() {
                "nav" if attributes.contains_key("links") => {
                    let mut attributes = attributes.clone();
                    attributes.insert("class".into(), "links".into());
                    let parent_id = tree.add_element_with_attributes("nav", attributes, parent_id);
                    for t in tokens {
                        match t {
                            Token::Link { text, href } => {
                                let parent_id = tree.add_element_with_attributes(
                                    "a",
                                    to_attributes([("href", href)]),
                                    parent_id,
                                );
                                let parent_id = tree.add_element_with_attributes(
                                    "div",
                                    to_attributes([("class", "card")]),
                                    parent_id,
                                );
                                tree.add_text(text, parent_id);
                            }
                            _ => {}
                        }
                    }
                }
                _ => {
                    let parent =
                        tree.add_element_with_attributes(tag, attributes.clone(), parent_id);
                    render_queue.push_tokens_front(tokens, parent)
                }
            },
            Token::Attributes { .. } | Token::Comment { .. } => {}
            Token::EOF => {}
        };
        true
    }
}
