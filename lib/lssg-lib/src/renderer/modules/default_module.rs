use std::{
    collections::HashMap,
    fs::{self, File},
    io::{self, Write},
    path::{Path, PathBuf},
};

use log::warn;
use serde::Serialize;
use serde_extensions::Overwrite;

use crate::{
    domtree::{to_attributes, DomNode, DomNodeKind},
    lmarkdown::{parse_lmarkdown, Token},
    lssg_error::LssgError,
    path_extension::PathExtension,
    sitetree::{Relation, SiteNodeKind, SiteTree},
    stylesheet::Stylesheet,
    tree::{Tree, DFS},
};

use crate::renderer::{RenderQueue, RendererModule, RendererModuleContext};

const WATERMARK: &'static str = r#"<footer id="watermark">Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a></footer>"#;

#[derive(Debug, Clone, Overwrite)]
struct DefaultModuleOptions {
    /// Add extra resources
    pub stylesheets: Vec<PathBuf>,
    pub favicon: Option<PathBuf>,

    pub title: String,
    /// Translates to meta tags <https://www.w3schools.com/tags/tag_meta.asp>
    pub meta: HashMap<String, String>,
    /// Lang attribute ("en") <https://www.w3schools.com/tags/ref_language_codes.asp>
    pub language: String,
}
impl DefaultModuleOptions {
    fn make_paths_absolute(&mut self, input: &Path) -> Result<(), LssgError> {
        let parent = input.parent().unwrap_or(Path::new(""));
        for path in self.stylesheets.iter_mut() {
            *path = fs::canonicalize(parent.join(&path))?;
        }
        if let Some(path) = &mut self.favicon {
            *path = fs::canonicalize(parent.join(&path))?;
        }

        Ok(())
    }
}
impl Default for DefaultModuleOptions {
    fn default() -> Self {
        Self {
            favicon: None,
            stylesheets: vec![],
            meta: HashMap::new(),
            title: String::new(),
            language: "en".into(),
        }
    }
}

fn create_options_map(
    module: &DefaultModule,
    site_tree: &SiteTree,
) -> Result<HashMap<usize, DefaultModuleOptions>, LssgError> {
    let mut options_map: HashMap<usize, DefaultModuleOptions> = HashMap::new();
    for id in DFS::new(site_tree) {
        if let SiteNodeKind::Page { tokens, input, .. } = &site_tree[id].kind {
            if let Some(parent) = site_tree.page_parent(id) {
                if let Some(parent_options) = options_map.get(&parent) {
                    let parent_options = parent_options.clone();
                    let mut options: DefaultModuleOptions =
                        module.options_with_default(tokens, parent_options);
                    options.make_paths_absolute(input)?;
                    options_map.insert(id, options.clone());
                    continue;
                }
            }

            let mut options: DefaultModuleOptions = module.options(tokens);
            options.make_paths_absolute(input)?;
            options_map.insert(id, options.clone());
        }
    }
    Ok(options_map)
}

/// Implements all basic default behavior, like rendering all tokens and adding meta tags and title to head
pub struct DefaultModule {
    /// Map of all site pages to options
    options_map: HashMap<usize, DefaultModuleOptions>,
}

impl DefaultModule {
    pub fn new() -> Self {
        Self {
            options_map: HashMap::new(),
        }
    }
}

impl RendererModule for DefaultModule {
    fn id(&self) -> &'static str {
        return "default";
    }

    /// Add all resources from ResourceOptions to SiteTree
    fn init(&mut self, site_tree: &mut SiteTree) -> Result<(), LssgError> {
        // get pages and options, each page will use its parent options and overwrite it
        let options_map = create_options_map(&self, site_tree)?;

        // create resources from options
        for id in site_tree.ids() {
            if let SiteNodeKind::Page { input, .. } = &site_tree[id].kind {
                let options = options_map
                    .get(&id)
                    .expect(&format!("options map is missing {id}"));
                let base_directory = fs::canonicalize(input.parent().unwrap_or(&input))?;

                for stylesheet_path in options.stylesheets.iter() {
                    let stylesheet_path = base_directory.join(stylesheet_path);
                    let mut stylesheet = Stylesheet::new();
                    stylesheet.append(&stylesheet_path)?;
                    let stylesheet_id = site_tree.add(
                        stylesheet_path.filename_from_path()?,
                        SiteNodeKind::stylesheet(stylesheet),
                        site_tree.root(),
                    )?;
                    site_tree.add_link(id, stylesheet_id);
                }

                if let Some(path) = &options.favicon {
                    let input = base_directory.join(path);
                    let favicon_id = site_tree.add(
                        "favicon.ico".into(),
                        SiteNodeKind::Resource { input },
                        site_tree.root(),
                    )?;
                    site_tree.add_link(id, favicon_id);
                }
            }
        }

        Ok(())
    }

    fn after_init(&mut self, site_tree: &SiteTree) -> Result<(), LssgError> {
        // save options map after site tree has been created to get all pages
        self.options_map = create_options_map(&self, site_tree)?;
        Ok(())
    }

    fn render_page<'n>(
        &mut self,
        dom_tree: &mut crate::domtree::DomTree,
        context: &super::RendererModuleContext<'n>,
    ) {
        let site_id = context.site_id;
        let site_tree = context.site_tree;

        let options = self
            .options_map
            .get(&site_id)
            .expect("expected options map to contain all page ids");

        // Add language to html tag
        let id = dom_tree.get_elements_by_tag_name("html")[0];
        if let Some(node) = dom_tree.get_mut(id) {
            if let DomNodeKind::Element { attributes, .. } = &mut node.kind {
                attributes.insert("lang".to_owned(), options.language.clone());
            }
        }

        // fill head
        let head = dom_tree.get_elements_by_tag_name("head")[0];

        let title = dom_tree.add(DomNode::element("title"), head);
        dom_tree.add_text(options.title.clone(), title);

        for link in site_tree.links_from(site_id) {
            match link.relation {
                Relation::External | Relation::Discovered { .. } => match site_tree[link.to].kind {
                    SiteNodeKind::Resource { .. } if site_tree[link.to].name == "favicon.ico" => {
                        dom_tree.add_element_with_attributes(
                            "link",
                            to_attributes([
                                ("rel", "icon"),
                                ("type", "image/x-icon"),
                                ("href", &site_tree.rel_path(site_id, link.to)),
                            ]),
                            head,
                        );
                    }
                    SiteNodeKind::Stylesheet { .. } => {
                        dom_tree.add_element_with_attributes(
                            "link",
                            to_attributes([
                                ("rel", "stylesheet"),
                                ("href", &site_tree.rel_path(site_id, link.to)),
                            ]),
                            head,
                        );
                    }
                    _ => {}
                },
                _ => {}
            }
        }
        dom_tree.add_element_with_attributes(
            "meta",
            to_attributes([
                ("name", "viewport"),
                ("content", r#"width=device-width, initial-scale=1"#),
            ]),
            head,
        );
        dom_tree.add(
            DomNode::element_with_attributes("meta", to_attributes([("charset", "utf-8")])),
            head,
        );
        for (key, value) in &options.meta {
            dom_tree.add(
                DomNode::element_with_attributes("meta", to_attributes([(key, value)])),
                head,
            );
        }
    }

    fn render_body<'n>(
        &mut self,
        tree: &mut crate::domtree::DomTree,
        context: &super::RendererModuleContext<'n>,
        render_queue: &mut RenderQueue,
        parent_id: usize,
        token: &crate::lmarkdown::Token,
    ) -> bool {
        let RendererModuleContext {
            site_tree, site_id, ..
        } = context;
        // TODO make work
        // let content_id =
        //     tree.add_element_with_attributes("div", to_attributes([("id", "content")]), body);
        match token {
            Token::Heading {
                depth,
                text: _,
                tokens,
            } => {
                let parent = tree.add(DomNode::element(format!("h{depth}")), parent_id);
                render_queue.push_tokens_front(tokens, parent)
            }
            Token::Paragraph { tokens } => {
                let parent = tree.add(DomNode::element("p"), parent_id);
                render_queue.push_tokens_front(tokens, parent)
            }
            Token::Bold { text } => {
                let parent = tree.add(DomNode::element("b"), parent_id);
                tree.add_text(text, parent);
            }
            Token::Italic { text } => {
                let parent = tree.add_element("i", parent_id);
                tree.add_text(text, parent);
            }
            Token::Code { code, language: _ } => {
                let parent = tree.add_element("code", parent_id);
                tree.add_text(code, parent);
            }
            Token::Space { raw: _ } => {
                tree.add_text("", parent_id);
            }
            Token::Link { text, href } => {
                if text.len() == 0 {
                    return true;
                }
                if href.starts_with("http") || href.starts_with("mailto:") {
                    let parent_id = tree.add_element_with_attributes(
                        "a",
                        to_attributes([("href", href)]),
                        parent_id,
                    );
                    tree.add_text(text, parent_id);
                    // TODO seperate from font awesome
                    tree.add_element_with_attributes(
                        "i",
                        to_attributes([
                            ("class", "fas fas-external-link-alt"),
                            ("style", "font-size: 0.8em"),
                        ]),
                        parent_id,
                    );
                    return true;
                }
                if href.ends_with(".md") {
                    let to_id = site_tree.links_from(*site_id).into_iter().find_map(|l| {
                        if let Relation::Discovered { path } = &l.relation {
                            if path == href {
                                return Some(l.to);
                            }
                        }
                        None
                    });
                    if let Some(to_id) = to_id {
                        let rel_path = site_tree.rel_path(*site_id, to_id);
                        let parent_id = tree.add_element_with_attributes(
                            "a",
                            to_attributes([("href", rel_path)]),
                            parent_id,
                        );
                        tree.add_text(text, parent_id);
                        return true;
                    }
                    warn!("Could not find node where {href:?} points to");
                }
                let parent_id = tree.add_element_with_attributes(
                    "a",
                    to_attributes([("href", href)]),
                    parent_id,
                );
                tree.add_text(text, parent_id);
            }
            Token::Text { text } => {
                tree.add_text(text, parent_id);
            }
            Token::Html {
                tag,
                attributes,
                tokens,
            } => match tag.as_str() {
                "nav" if attributes.contains_key("links") => {
                    let mut attributes = attributes.clone();
                    attributes.insert("class".into(), "links".into());
                    let parent_id = tree.add_element_with_attributes("nav", attributes, parent_id);
                    for t in tokens {
                        match t {
                            Token::Link { text, href } => {
                                let parent_id = tree.add_element_with_attributes(
                                    "a",
                                    to_attributes([("href", href)]),
                                    parent_id,
                                );
                                let parent_id = tree.add_element_with_attributes(
                                    "div",
                                    to_attributes([("class", "card")]),
                                    parent_id,
                                );
                                tree.add_text(text, parent_id);
                            }
                            _ => {}
                        }
                    }
                }
                _ => {
                    let parent =
                        tree.add_element_with_attributes(tag, attributes.clone(), parent_id);
                    render_queue.push_tokens_front(tokens, parent)
                }
            },
            Token::Attributes { .. } | Token::Comment { .. } => {}
            Token::EOF => {}
        };
        true
    }
}
