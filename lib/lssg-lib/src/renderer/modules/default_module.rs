use std::{
    collections::HashMap,
    iter::{self},
};

use constants::{DEFAULT_JS, DEFAULT_STYLESHEET};
use log::{error, warn};

use proc_virtual_dom::dom;
use regex::Regex;
use serde::Deserialize;
use serde_extensions::Overwrite;

use crate::{
    lmarkdown::Token,
    lssg_error::LssgError,
    renderer::{modules::default_module::nav::NavOptions, util::OneOrManyOption},
    sitetree::{Input, Relation, Resource, SiteId, SiteNode, SiteNodeKind, SiteTree, Stylesheet},
    tree::Dfs,
};
use virtual_dom::{
    self, Document, DomNode, DomNodeKind, Html, parse_html, parse_html_from_string, to_attributes,
};

use crate::renderer::{RenderContext, RendererModule, TokenRenderer};

use super::util::{process_href, tokens_to_text};

mod constants;
mod nav;
mod render_html;

const PRISM_CSS: &[u8] = include_bytes!("./default_module/prism.css");
const PRISM_JS: &str = include_str!("./default_module/prism.js");

const SUPPORTED_VIDEO_FORMATS: [&str; 6] = ["mp4", "webm", "ogg", "ogv", "mov", "avi"];

#[derive(Debug, Clone, Deserialize, Overwrite)]
#[serde(default)]
struct FooterOptions {
    /// Every item you want to include in your footer
    items: Vec<String>,
    /// Overwrite footer with custom html element
    custom: Option<String>,

    /// Enable `Generated by Lssg` watermark
    watermark: bool,
}
impl Default for FooterOptions {
    fn default() -> Self {
        Self {
            items: vec![],
            custom: None,
            watermark: true,
        }
    }
}

#[derive(Debug, Clone, Deserialize, Overwrite)]
#[serde(default)]
struct PropegatedOptions {
    /// Add extra resources
    pub title: Option<String>,
    /// Translates to meta tags <https://www.w3schools.com/tags/tag_meta.asp>
    pub meta: HashMap<String, String>,
    /// Lang attribute ("en" by default) <https://www.w3schools.com/tags/ref_language_codes.asp>
    pub language: String,
    /// Any other custom html that you want to put in the script
    pub head: Vec<String>,
    /// Custom html fields in the footer
    pub footer: FooterOptions,
    pub nav: OneOrManyOption<NavOptions>,
    /// Enable section links on h2 headers (default: true)
    pub section_links: bool,
}

impl Default for PropegatedOptions {
    fn default() -> Self {
        Self {
            meta: HashMap::new(),
            title: None,
            language: "en".into(),
            head: vec![],
            footer: FooterOptions::default(),
            nav: OneOrManyOption::One(NavOptions::default()),
            section_links: true,
        }
    }
}

/// Wrapper that tracks which site ID these options originated from
#[derive(Debug, Clone)]
struct PropegatedOptionsWithRoot {
    pub options: PropegatedOptions,
    /// The site id where `root=true`
    pub root_site_id: Option<SiteId>,
}

#[derive(Debug, Clone, Overwrite, Default)]
pub struct SinglePageOptions {
    /// If this page is a root don't reuse options from parent
    pub root: bool,
}

fn create_options_map(site_tree: &SiteTree) -> HashMap<SiteId, PropegatedOptionsWithRoot> {
    let mut options_map: HashMap<SiteId, PropegatedOptionsWithRoot> = HashMap::new();
    for id in Dfs::new(site_tree) {
        if let SiteNodeKind::Page(page) = &site_tree[id].kind {
            let is_root = page
                .attributes()
                .and_then(|attributes| attributes.get("root").and_then(|v| v.as_bool()))
                .unwrap_or(false);

            let (mut options, root_id) = if is_root {
                // If root=true, start with default options instead of inheriting from parent
                (PropegatedOptions::default(), Some(id))
            } else if let Some(parent_opts) = site_tree
                .page_parent(id)
                .and_then(|id| options_map.get(&id))
            {
                // Inherit from parent, preserving the root_site_id
                (parent_opts.options.clone(), parent_opts.root_site_id)
            } else {
                // No parent, start fresh
                (PropegatedOptions::default(), Some(id))
            };

            if let Some(attributes) = page.attributes() {
                options
                    .overwrite(attributes)
                    .inspect_err(|e| {
                        log::error!("Failed to parse options for page {id}, using defaults: {e}")
                    })
                    .unwrap_or_default();
            }

            options_map.insert(
                id,
                PropegatedOptionsWithRoot {
                    options,
                    root_site_id: root_id,
                },
            );
        }
    }
    options_map
}

/// Render everything meant to go into <head>
fn head(document: &mut Document, context: &RenderContext, options: &PropegatedOptions) {
    let RenderContext {
        site_id,
        site_tree,
        page,
        ..
    } = context;
    let site_id = *site_id;

    let head = &document.head;
    let mut title = options.title.clone();
    if let Some(header) = page
        .tokens()
        .iter()
        .find(|t| matches!(t, Token::Heading { depth: 1, .. }))
        .cloned()
    {
        let header = tokens_to_text(&vec![header]);
        title = Some(format!(
            "{header}{}",
            title.map_or("".into(), |t| format!(" | {t}"))
        ));
    }

    if let Some(title) = title {
        let t = title.clone();
        head.append_child(dom!(<title>{t}</title>));
        head.append_child(dom!(<meta property="og:title" content="{title}" />));
        head.append_child(dom!(<meta name="twitter:title" content="{title}" />));
    }

    // add stylesheets and favicon
    // NOTE: reverse the order of insertion because latest css is applied last
    for link in site_tree.links_from(site_id).into_iter().rev() {
        match link.relation {
            Relation::External | Relation::Discovered { .. } => match &site_tree[link.to].kind {
                SiteNodeKind::Resource { .. } if site_tree[link.to].name == "favicon.ico" => {
                    head.append_child(document.create_element_with_attributes(
                        "link",
                        to_attributes([
                            ("rel", "icon"),
                            ("type", "image/x-icon"),
                            ("href", &site_tree.rel_path(site_id, link.to)),
                        ]),
                    ));
                }
                SiteNodeKind::Javascript(javascript) => {
                    let mode = javascript.mode();
                    let path = site_tree.rel_path(site_id, link.to);
                    let el = document.create_element_with_attributes(
                        "script",
                        to_attributes(
                            mode.attributes()
                                .iter()
                                .map(|(a, b)| (a.to_string(), b.to_string()))
                                .chain(iter::once(("src".to_string(), path))),
                        ),
                    );
                    if mode.in_body() {
                        document.body.prepend(el);
                    } else {
                        head.append_child(el);
                    }
                }
                SiteNodeKind::Resource { .. } if site_tree[link.to].name.ends_with("js") => {
                    let path = &site_tree.rel_path(site_id, link.to);
                    head.append_child(dom!(<script src="{path}" defer></script>));
                }
                SiteNodeKind::Stylesheet { .. } => {
                    head.append_child(document.create_element_with_attributes(
                        "link",
                        to_attributes([
                            ("rel", "stylesheet"),
                            ("href", &site_tree.rel_path(site_id, link.to)),
                        ]),
                    ));
                }
                _ => {}
            },
        }
    }

    // meta tags
    head.append_child(document.create_element_with_attributes(
        "meta",
        to_attributes([
            ("name", "viewport"),
            ("content", r#"width=device-width, initial-scale=1"#),
        ]),
    ));
    head.append_child(
        document.create_element_with_attributes("meta", to_attributes([("charset", "utf-8")])),
    );

    for input in &options.head {
        let html = match parse_html_from_string(input) {
            Ok(html) => {
                if html.len() > 2 {
                    warn!("{html:?} has more than two html elements");
                }
                let Some(html) = html.into_iter().next() else {
                    warn!("{input:?} did not contain a single html element");
                    continue;
                };
                html
            }
            Err(e) => {
                warn!("Error while parsing html {e}");
                continue;
            }
        };
        head.append_child(html);
    }

    for (key, value) in &options.meta {
        if key == "description" {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("name", key), ("content", value)]),
            ));
        }
        match key.as_str() {
            "description" | "image" => {
                head.append_child(document.create_element_with_attributes(
                    "meta",
                    to_attributes([("property", &format!("og:{}", key)), ("content", value)]),
                ));
                head.append_child(document.create_element_with_attributes(
                    "meta",
                    to_attributes([("name", &format!("twitter:{}", key)), ("content", value)]),
                ));
                continue;
            }
            _ => {}
        }
        // Open Graph (https://ogp.me/) uses property instead of name
        if key.starts_with("og:") {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("property", key), ("content", value)]),
            ));
        } else {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("name", key), ("content", value)]),
            ));
        }
    }
}

fn section_link(document: &mut Document) {
    // Add link icons to each h2 header
    let content = document.body.get_element_by_id("default__content");
    if let Some(content) = content {
        for mut heading in content.get_elements_by_tag_name("h2") {
            let id = match heading.get_attribute("id") {
                Some(id) => id,
                None => {
                    let id = heading.inner_text().to_ascii_lowercase().replace(" ", "-");
                    heading.set_attribute("id", &id);
                    id
                }
            };
            let link = dom!(
                <a href="#{id}" class="default__section-link" aria-hidden=true>
                    <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 640 640"><path d="M451.5 160C434.9 160 418.8 164.5 404.7 172.7C388.9 156.7 370.5 143.3 350.2 133.2C378.4 109.2 414.3 96 451.5 96C537.9 96 608 166 608 252.5C608 294 591.5 333.8 562.2 363.1L491.1 434.2C461.8 463.5 422 480 380.5 480C294.1 480 224 410 224 323.5C224 322 224 320.5 224.1 319C224.6 301.3 239.3 287.4 257 287.9C274.7 288.4 288.6 303.1 288.1 320.8C288.1 321.7 288.1 322.6 288.1 323.4C288.1 374.5 329.5 415.9 380.6 415.9C405.1 415.9 428.6 406.2 446 388.8L517.1 317.7C534.4 300.4 544.2 276.8 544.2 252.3C544.2 201.2 502.8 159.8 451.7 159.8zM307.2 237.3C305.3 236.5 303.4 235.4 301.7 234.2C289.1 227.7 274.7 224 259.6 224C235.1 224 211.6 233.7 194.2 251.1L123.1 322.2C105.8 339.5 96 363.1 96 387.6C96 438.7 137.4 480.1 188.5 480.1C205 480.1 221.1 475.7 235.2 467.5C251 483.5 269.4 496.9 289.8 507C261.6 530.9 225.8 544.2 188.5 544.2C102.1 544.2 32 474.2 32 387.7C32 346.2 48.5 306.4 77.8 277.1L148.9 206C178.2 176.7 218 160.2 259.5 160.2C346.1 160.2 416 230.8 416 317.1C416 318.4 416 319.7 416 321C415.6 338.7 400.9 352.6 383.2 352.2C365.5 351.8 351.6 337.1 352 319.4C352 318.6 352 317.9 352 317.1C352 283.4 334 253.8 307.2 237.5z"/></svg>
                </a>
            );
            heading.prepend(link);
        }
    }
}

/// Implements all basic default behavior, like rendering all tokens and adding meta tags and title to head
#[derive(Default)]
pub struct DefaultModule {
    /// Map of all site pages to options. Considers options from parents.
    options_map: HashMap<SiteId, PropegatedOptionsWithRoot>,
}

impl RendererModule for DefaultModule {
    fn id(&self) -> &'static str {
        "default"
    }

    /// Add all resources from ResourceOptions to SiteTree
    fn init(&mut self, site_tree: &mut SiteTree) -> Result<(), LssgError> {
        let pages: Vec<SiteId> = Dfs::new(site_tree)
            .filter(|id| site_tree[*id].kind.is_page())
            .collect();

        let default_links = [
            site_tree.add(SiteNode::stylesheet(
                "default.css",
                site_tree.root(),
                Stylesheet::from_readable(DEFAULT_STYLESHEET)?,
            )),
            site_tree.add(SiteNode::resource(
                "default.js",
                site_tree.root(),
                Resource::new_static(DEFAULT_JS.to_owned()),
            )),
            site_tree.add(SiteNode::stylesheet(
                "prism.css",
                site_tree.root(),
                Stylesheet::from_readable(PRISM_CSS)?,
            )),
            site_tree.add(SiteNode::resource(
                "prism.js",
                site_tree.root(),
                Resource::new_static(PRISM_JS.to_owned()),
            )),
        ];
        for id in default_links.iter() {
            site_tree.add_link(site_tree.root(), *id, Relation::External);
        }

        let mut relation_map: HashMap<SiteId, Vec<SiteId>> = HashMap::new();
        // propegate relations to stylesheets, favicon and js from parent to child
        for id in pages {
            // get the set of links to favicon and stylesheets
            let set: Vec<SiteId> = site_tree
                .links_from(id)
                .into_iter()
                .filter_map(|link| match link.relation {
                    Relation::External | Relation::Discovered { .. } => {
                        let node = &site_tree[link.to];
                        match node.kind {
                            SiteNodeKind::Stylesheet { .. } => Some(link.to),
                            SiteNodeKind::Resource { .. }
                                if node.name == "favicon.ico" || node.name.ends_with(".js") =>
                            {
                                Some(link.to)
                            }
                            _ => None,
                        }
                    }
                })
                .collect();

            let is_root = if let SiteNodeKind::Page(page) = &site_tree[id].kind {
                let opts: SinglePageOptions = self.options(page);
                opts.root
            } else {
                false
            };

            let parent_set = if let Some(parent) = site_tree.page_parent(id)
                && let Some(parent_set) = relation_map.get(&parent)
                && !is_root
            {
                parent_set
            } else {
                &default_links.into()
            };

            // add links from parent_set without the ones it already has
            let mut new_links: Vec<SiteId> = parent_set
                .iter()
                .filter(|id| !set.contains(id))
                .cloned()
                .collect();
            for to in new_links.iter() {
                site_tree.add_link(id, *to, Relation::External);
            }
            new_links.extend(set.iter());
            relation_map.insert(id, new_links);
        }

        Ok(())
    }

    fn after_init(&mut self, site_tree: &SiteTree) -> Result<(), LssgError> {
        // save options map after site tree has been created to get all pages
        self.options_map = create_options_map(site_tree);
        Ok(())
    }

    fn after_render<'n>(&mut self, document: &mut Document, ctx: &RenderContext<'n>) {
        let site_id = ctx.site_id;
        let opts = self
            .options_map
            .get(&site_id)
            .expect("expected options map to contain all page ids");
        let options = &opts.options;

        // add breacrumbs if not root
        nav::nav(opts, document, ctx);

        let body = &document.body;

        // move all dom elements to under #content
        let content = document
            .create_element_with_attributes("main", to_attributes([("id", "default__content")]));
        for child in body.children() {
            child.detach();
            content.append_child(child);
        }
        body.append_child(content);

        if let Some(footer) = options.footer.custom.as_ref() {
            if let Ok(html) = virtual_dom::parse_html_from_string(footer) {
                body.append_child(html);
            }
        } else {
            let mut items = options.footer.items.clone();

            if options.footer.watermark {
                items.push(
                    r#"Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a>"#.into(),
                );
            }

            let mut footer = DomNode::create_element("footer");
            footer.set_attribute("id", "default__footer");
            let mut items = items.into_iter().peekable();
            while let Some(item) = items.next() {
                if let Ok(item) = virtual_dom::parse_html_from_string(&item) {
                    footer.append_child(item);
                }
                if items.peek().is_some() {
                    footer.append_child(" | ");
                }
            }
            body.append_child(footer);
        }

        // Add language to html tag
        if let DomNodeKind::Element { attributes, .. } = &mut *document.root().kind_mut() {
            attributes.insert("lang".to_owned(), options.language.clone());
        }

        // fill head
        head(document, ctx, options);

        if options.section_links {
            section_link(document);
        }
    }

    fn render_body<'n>(
        &mut self,
        document: &mut Document,
        ctx: &super::RenderContext<'n>,
        parent: DomNode,
        token: &crate::lmarkdown::Token,
        tr: &mut TokenRenderer,
    ) -> Option<DomNode> {
        match token {
            Token::OrderedList { items, start, .. } => {
                let mut ol = document.create_element("ol");
                if *start != 0 && *start != 1 {
                    ol.set_attribute("start", &start.to_string());
                }
                for tokens in items {
                    let li = document.create_element("li");
                    ol.append_child(li.clone());
                    // don't render paragraphs inside of lists
                    let tokens: Vec<Token> = tokens
                        .iter()
                        .flat_map(|t| {
                            if let Token::Paragraph { tokens, .. } = t {
                                return tokens.clone();
                            }
                            vec![t.clone()]
                        })
                        .collect();
                    tr.render(document, ctx, li, &tokens);
                }
                parent.append_child(ol);
            }
            Token::BulletList { items, .. } => {
                let ul = document.create_element("ul");
                for tokens in items {
                    let li = document.create_element("li");
                    ul.append_child(li.clone());
                    // don't render paragraphs inside of lists
                    let tokens: Vec<Token> = tokens
                        .iter()
                        .flat_map(|t| {
                            if let Token::Paragraph { tokens, .. } = t {
                                return tokens.clone();
                            }
                            vec![t.clone()]
                        })
                        .collect();
                    tr.render(document, ctx, li, &tokens);
                }
                parent.append_child(ul);
            }
            Token::Attributes { .. } | Token::Comment { .. } => {}

            Token::ThematicBreak => {
                parent.append_child(document.create_element("hr"));
            }
            Token::Image { tokens, src, title } => {
                let mut resource_id = None;
                // if local page return relative src
                let src = if Input::is_relative(src) {
                    let to_id = ctx
                        .site_tree
                        .links_from(ctx.site_id)
                        .into_iter()
                        .find_map(|l| {
                            if let Relation::Discovered { raw_path: path } = &l.relation
                                && path == src
                            {
                                return Some(l.to);
                            }
                            None
                        });

                    if let Some(to_id) = to_id {
                        resource_id = Some(to_id);
                        ctx.site_tree.path(to_id)
                    } else {
                        warn!("Could not find node where {src:?} points to");
                        src.to_owned()
                    }
                } else {
                    src.to_owned()
                };

                // inject svg into html
                if src.ends_with(".svg") {
                    let readable = if let Some(id) = resource_id {
                        match &ctx.site_tree[id].kind {
                            SiteNodeKind::Resource(r) => r.readable(),
                            _ => {
                                warn!("svg is not found as a resource");
                                return Some(parent);
                            }
                        }
                    } else {
                        match Input::from_string(&src) {
                            Ok(i) => i.readable(),
                            Err(e) => {
                                error!("failed to get svg: {e}");
                                return Some(parent);
                            }
                        }
                    };

                    match readable {
                        Ok(r) => {
                            // get first valid html tag
                            let mut html = parse_html(r)
                                .unwrap()
                                .into_iter()
                                .find(|e| match e {
                                    Html::Comment { .. } | Html::Text { .. } => false,
                                    Html::Element { .. } => true,
                                })
                                .expect("invalid svg, no html elements founds");

                            match &mut html {
                                Html::Element { attributes, .. } => {
                                    // set viewbox to allow scaling of svg using width and height
                                    if attributes.get("viewbox").is_none() {
                                        let re = Regex::new(r"[0-9]*").unwrap();
                                        let width = if let Some(width) = attributes.get("width") {
                                            re.captures(width)
                                                .map(|c| c[0].to_string())
                                                .unwrap_or(width.clone())
                                        } else {
                                            warn!("no width found for svg, using default of 300");
                                            "300".to_string()
                                        };
                                        let height = if let Some(height) = attributes.get("height")
                                        {
                                            re.captures(height)
                                                .map(|c| c[0].to_string())
                                                .unwrap_or(width.clone())
                                        } else {
                                            warn!("no height found for svg, using default of 150");
                                            "150".to_string()
                                        };
                                        attributes.insert(
                                            "viewbox".into(),
                                            format!("0 0 {width} {height}"),
                                        );
                                    }
                                    attributes.remove(&"style".to_string());
                                    attributes.remove(&"width".to_string());
                                    attributes.remove(&"height".to_string());

                                    parent.append_child(html);
                                    return Some(parent);
                                }
                                _ => error!("svg must be an element"),
                            }
                        }

                        Err(e) => {
                            error!("failed to read {src}: {e}");
                            return Some(parent);
                        }
                    }
                }

                if let Some(format) = SUPPORTED_VIDEO_FORMATS
                    .iter()
                    .find(|format| src.ends_with(&format!(".{format}")))
                {
                    let format = format.to_string();
                    parent.append_child(
                        dom!(<video controls><source src="{src}" type="video/{format}"></video>),
                    );
                    return Some(parent);
                }

                let alt = tokens_to_text(tokens);
                if let Some(title) = title {
                    parent.append_child(dom!(<img src="{src}" alt="{alt}" title={title} />))
                } else {
                    parent.append_child(dom!(<img src="{src}" alt="{alt}" />))
                }
            }
            Token::BlockQuote { tokens, .. } => {
                let blockquote = document.create_element("blockquote");
                tr.render(document, ctx, blockquote.clone(), tokens);
                parent.append_child(blockquote);
            }
            Token::HardBreak => {
                parent.append_child(document.create_element("br"));
            }
            Token::SoftBreak => {
                parent.append_child(document.create_text_node(" "));
            }
            Token::Heading { depth, tokens, .. } => {
                let heading = document.create_element(format!("h{depth}"));
                tr.render(document, ctx, heading.clone(), tokens);
                parent.append_child(heading)
            }
            Token::Paragraph { tokens, .. } => {
                let p = document.create_element("p");
                tr.render(document, ctx, p.clone(), tokens);
                parent.append_child(p)
            }
            Token::Bold { text } => {
                let b = document.create_element("b");
                b.append_child(document.create_text_node(text));
                parent.append_child(b)
            }
            Token::Emphasis { text } => {
                let e = document.create_element("em");
                e.append_child(document.create_text_node(text));
                parent.append_child(e)
            }
            Token::Code { text: code } => {
                let code_html = document.create_element("code");
                code_html.append_child(document.create_text_node(code));
                parent.append_child(code_html)
            }
            Token::CodeBlock { text: code, info } => {
                let mut code_html = document.create_element("code");
                if let Some(info) = info {
                    code_html.set_attribute(
                        "class",
                        &format!("language-{info} copy-to-clipboard-button"),
                    );
                    code_html.set_attribute("data-copy-state", "copy");
                }
                code_html.append_child(document.create_text_node(code));
                let pre = document.create_element("pre");
                pre.append_child(code_html);
                parent.append_child(pre)
            }
            Token::Autolink { href, text } => {
                let mut a = document.create_element("a");
                a.set_attribute("href", href);
                a.append_child(document.create_text_node(text));
                parent.append_child(a);
            }
            Token::Link {
                tokens,
                href,
                title,
            } => {
                // ignore link if there is no text
                if tokens.is_empty() {
                    return Some(parent);
                }

                let href = &process_href(href, ctx);
                // if link to resource add path
                let href = if let Some(to_id) = ctx
                    .site_tree
                    .links_from(ctx.site_id)
                    .into_iter()
                    .find_map(|l| {
                        if let Relation::Discovered { raw_path: path } = &l.relation
                            && path == href
                        {
                            return Some(l.to);
                        }
                        None
                    }) {
                    ctx.site_tree.path(to_id)
                } else {
                    href.to_owned()
                };

                let mut attributes = to_attributes([("href", href)]);
                if let Some(title) = title {
                    attributes.insert("title".to_owned(), title.to_owned());
                }
                let a = document.create_element_with_attributes("a", attributes);
                tr.render(document, ctx, a.clone(), tokens);
                parent.append_child(a);
            }
            Token::Text { text } => {
                parent.append_child(document.create_text_node(text));
            }
            Token::Html {
                tag,
                attributes,
                tokens,
            } => {
                if let Some(parent) =
                    render_html::render_html(document, ctx, &parent, tr, tag, attributes, tokens)
                {
                    return Some(parent);
                }
            }
            Token::Table {
                header,
                align,
                rows,
            } => {
                use crate::lmarkdown::TableAlign;

                let table = document.create_element("table");

                // Render thead
                let thead = document.create_element("thead");
                let header_row = document.create_element("tr");
                for (i, cell_tokens) in header.iter().enumerate() {
                    let mut th = document.create_element("th");
                    if let Some(alignment) = align.get(i) {
                        match alignment {
                            TableAlign::Left => th.set_attribute("align", "left"),
                            TableAlign::Center => th.set_attribute("align", "center"),
                            TableAlign::Right => th.set_attribute("align", "right"),
                            TableAlign::None => {}
                        }
                    }
                    tr.render(document, ctx, th.clone(), cell_tokens);
                    header_row.append_child(th);
                }
                thead.append_child(header_row);
                table.append_child(thead);

                // Render tbody
                if !rows.is_empty() {
                    let tbody = document.create_element("tbody");
                    for row in rows {
                        let tr_elem = document.create_element("tr");
                        for (i, cell_tokens) in row.iter().enumerate() {
                            let mut td = document.create_element("td");
                            if let Some(alignment) = align.get(i) {
                                match alignment {
                                    TableAlign::Left => td.set_attribute("align", "left"),
                                    TableAlign::Center => td.set_attribute("align", "center"),
                                    TableAlign::Right => td.set_attribute("align", "right"),
                                    TableAlign::None => {}
                                }
                            }
                            tr.render(document, ctx, td.clone(), cell_tokens);
                            tr_elem.append_child(td);
                        }
                        tbody.append_child(tr_elem);
                    }
                    table.append_child(tbody);
                }

                parent.append_child(table);
            }
        };
        // always renders
        Some(parent)
    }
}
