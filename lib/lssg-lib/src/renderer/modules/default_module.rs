use std::collections::HashMap;

use constants::{DEFAULT_JS, DEFAULT_STYLESHEET};
use log::{error, warn};

use proc_virtual_dom::dom;
use regex::Regex;
use serde::Deserialize;
use serde_extensions::Overwrite;

use crate::{
    lmarkdown::Token,
    lssg_error::LssgError,
    sitetree::{
        Input, Page, Relation, Resource, SiteId, SiteNode, SiteNodeKind, SiteTree, Stylesheet,
    },
    tree::DFS,
};
use virtual_dom::{
    self, parse_html, parse_html_from_string, to_attributes, Document, DomNode, DomNodeKind, Html,
};

use crate::renderer::{RenderContext, RendererModule, TokenRenderer};

use super::util::{process_href, tokens_to_text};

mod constants;
mod nav;
mod render_html;

const PRISM_CSS: &[u8] = include_bytes!("./default_module/prism.css");
const PRISM_JS: &str = include_str!("./default_module/prism.js");

const SUPPORTED_VIDEO_FORMATS: [&str; 6] = ["mp4", "webm", "ogg", "ogv", "mov", "avi"];

#[derive(Debug, Clone, Deserialize, Overwrite)]
#[serde(default)]
struct Footer {
    /// Every item you want to include in your footer
    items: Vec<String>,
    /// Overwrite footer with custom html element
    custom: Option<String>,

    /// Enable `Generated by Lssg` watermark
    watermark: bool,
}
impl Default for Footer {
    fn default() -> Self {
        Self {
            items: vec![],
            custom: None,
            watermark: true,
        }
    }
}

#[derive(Debug, Clone, Deserialize, Overwrite)]
#[serde(default)]
struct PropegatedOptions {
    /// Add extra resources
    pub title: Option<String>,
    /// Translates to meta tags <https://www.w3schools.com/tags/tag_meta.asp>
    pub meta: HashMap<String, String>,
    /// Lang attribute ("en" by default) <https://www.w3schools.com/tags/ref_language_codes.asp>
    pub language: String,
    /// Any other custom html that you want to put in the script
    pub head: Vec<String>,
    /// Custom html fields in the footer
    pub footer: Footer,
}
impl Default for PropegatedOptions {
    fn default() -> Self {
        Self {
            meta: HashMap::new(),
            title: None,
            language: "en".into(),
            head: vec![],
            footer: Footer::default(),
        }
    }
}

#[derive(Debug, Clone, Overwrite)]
pub struct SinglePageOptions {
    /// If this page is a root don't reuse options from parent
    pub root: bool,
}
impl Default for SinglePageOptions {
    fn default() -> Self {
        Self { root: false }
    }
}

fn create_options_map(
    site_tree: &SiteTree,
) -> Result<HashMap<SiteId, PropegatedOptions>, LssgError> {
    let mut options_map: HashMap<SiteId, PropegatedOptions> = HashMap::new();
    for id in DFS::new(site_tree) {
        if let SiteNodeKind::Page(page) = &site_tree[id].kind {
            let mut options = if let Some(parent_options) = site_tree
                .page_parent(id)
                .map(|id| options_map.get(&id))
                .flatten()
            {
                parent_options.clone()
            } else {
                PropegatedOptions::default()
            };
            if let Some(attributes) = page.attributes() {
                options
                    .overwrite(attributes)
                    .map_err(|e| LssgError::parse(format!("Failed to parse options: {e}")))?;
            }
            options_map.insert(id, options.clone());
        }
    }
    Ok(options_map)
}

/// Render everything meant to go into <head>
fn head(document: &mut Document, context: &RenderContext, options: &PropegatedOptions) {
    let RenderContext {
        site_id,
        site_tree,
        page,
        ..
    } = context;
    let site_id = *site_id;

    let head = &document.head;
    let mut title = options.title.clone();
    if let Some(header) = page
        .tokens()
        .iter()
        .find(|t| {
            if let Token::Heading { depth, .. } = t {
                return *depth == 1;
            }
            false
        })
        .cloned()
    {
        let header = tokens_to_text(&vec![header]);
        title = Some(format!(
            "{header}{}",
            title.map_or("".into(), |t| format!(" | {t}"))
        ));
    }

    if let Some(title) = title {
        let t = title.clone();
        head.append_child(dom!(<title>{t}</title>));
        head.append_child(dom!(<meta property="og:title" content="{title}" />));
        head.append_child(dom!(<meta name="twitter:title" content="{title}" />));
    }

    // add stylesheets and favicon
    // reverse the order of insertion because latest css is applied last
    for link in site_tree.links_from(site_id).into_iter().rev() {
        match link.relation {
            Relation::External | Relation::Discovered { .. } => match site_tree[link.to].kind {
                SiteNodeKind::Resource { .. } if site_tree[link.to].name == "favicon.ico" => {
                    head.append_child(document.create_element_with_attributes(
                        "link",
                        to_attributes([
                            ("rel", "icon"),
                            ("type", "image/x-icon"),
                            ("href", &site_tree.rel_path(site_id, link.to)),
                        ]),
                    ));
                }
                SiteNodeKind::Resource { .. } if site_tree[link.to].name.ends_with("js") => {
                    let path = &site_tree.rel_path(site_id, link.to);
                    document
                        .body
                        .append_child(dom!(<script src="{path}"></script>));
                }
                SiteNodeKind::Stylesheet { .. } => {
                    head.append_child(document.create_element_with_attributes(
                        "link",
                        to_attributes([
                            ("rel", "stylesheet"),
                            ("href", &site_tree.rel_path(site_id, link.to)),
                        ]),
                    ));
                }
                _ => {}
            },
            _ => {}
        }
    }

    // meta tags
    head.append_child(document.create_element_with_attributes(
        "meta",
        to_attributes([
            ("name", "viewport"),
            ("content", r#"width=device-width, initial-scale=1"#),
        ]),
    ));
    head.append_child(
        document.create_element_with_attributes("meta", to_attributes([("charset", "utf-8")])),
    );

    for input in &options.head {
        let html = match parse_html_from_string(&input) {
            Ok(html) => {
                if html.len() > 2 {
                    warn!("{html:?} has more than two html elements");
                }
                let Some(html) = html.into_iter().next() else {
                    warn!("{input:?} did not contain a single html element");
                    continue;
                };
                html
            }
            Err(e) => {
                warn!("Error while parsing html {e}");
                continue;
            }
        };
        head.append_child(html);
    }

    for (key, value) in &options.meta {
        if key == "description" {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("name", key), ("content", value)]),
            ));
        }
        match key.as_str() {
            "description" | "image" => {
                head.append_child(document.create_element_with_attributes(
                    "meta",
                    to_attributes([("property", &format!("og:{}", key)), ("content", value)]),
                ));
                head.append_child(document.create_element_with_attributes(
                    "meta",
                    to_attributes([("name", &format!("twitter:{}", key)), ("content", value)]),
                ));
                continue;
            }
            _ => {}
        }
        // Open Graph (https://ogp.me/) uses property instead of name
        if key.starts_with("og:") {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("property", key), ("content", value)]),
            ));
        } else {
            head.append_child(document.create_element_with_attributes(
                "meta",
                to_attributes([("name", key), ("content", value)]),
            ));
        }
    }
}

/// Implements all basic default behavior, like rendering all tokens and adding meta tags and title to head
pub struct DefaultModule {
    /// Map of all site pages to options. Considers options from parents.
    options_map: HashMap<SiteId, PropegatedOptions>,
}

impl DefaultModule {
    pub fn new() -> Self {
        Self {
            options_map: HashMap::new(),
        }
    }
}

impl RendererModule for DefaultModule {
    fn id(&self) -> &'static str {
        "default"
    }

    /// Add all resources from ResourceOptions to SiteTree
    fn init(&mut self, site_tree: &mut SiteTree) -> Result<(), LssgError> {
        let pages: Vec<SiteId> = DFS::new(site_tree)
            .filter(|id| site_tree[*id].kind.is_page())
            .collect();

        let prism_js = site_tree.add(SiteNode::resource(
            "prism.js",
            site_tree.root(),
            Resource::new_static(PRISM_JS.to_owned()),
        ));
        site_tree.add_link(site_tree.root(), prism_js);
        let default_js = site_tree.add(SiteNode::stylesheet(
            "prism.css",
            site_tree.root(),
            Stylesheet::from_readable(PRISM_CSS)?,
        ));
        site_tree.add_link(site_tree.root(), default_js);

        let default_js = site_tree.add(SiteNode::resource(
            "default.js",
            site_tree.root(),
            Resource::new_static(DEFAULT_JS.to_owned()),
        ));
        site_tree.add_link(site_tree.root(), default_js);

        let default_stylesheet = site_tree.add(SiteNode::stylesheet(
            "default.css",
            site_tree.root(),
            Stylesheet::from_readable(DEFAULT_STYLESHEET)?,
        ));
        site_tree.add_link(site_tree.root(), default_stylesheet);

        let mut relation_map: HashMap<SiteId, Vec<SiteId>> = HashMap::new();
        // propegate relations to stylesheets, favicon and js from parent to child
        for id in pages {
            // skip page if disabled
            if let SiteNodeKind::Page(page) = &site_tree[id].kind {
                let opts: SinglePageOptions = self.options(page);
                if opts.root {
                    continue;
                }
            }

            // get the set of links to favicon and stylesheets
            let mut set: Vec<SiteId> = site_tree
                .links_from(id)
                .into_iter()
                .filter_map(|link| match link.relation {
                    Relation::External | Relation::Discovered { .. } => {
                        let node = &site_tree[link.to];
                        match node.kind {
                            SiteNodeKind::Stylesheet { .. } => Some(link.to),
                            SiteNodeKind::Resource { .. }
                                if node.name == "favicon.ico" || node.name.ends_with(".js") =>
                            {
                                Some(link.to)
                            }
                            _ => None,
                        }
                    }
                    _ => None,
                })
                .collect();

            // update set with parent and add any links from parent
            if let Some(parent) = site_tree.page_parent(id) {
                if let Some(parent_set) = relation_map.get(&parent) {
                    // 0 [28, 29, 32, 35, 37, 49]
                    // add links from parent_set without the ones it already has
                    let mut new_links: Vec<SiteId> = parent_set
                        .into_iter()
                        .filter(|id| !set.contains(id))
                        .cloned()
                        .collect();
                    for to in new_links.iter() {
                        site_tree.add_link(id, *to);
                    }
                    new_links.extend(set.iter());
                    set = new_links;
                }
            }
            relation_map.insert(id, set);
        }

        Ok(())
    }

    fn after_init(&mut self, site_tree: &SiteTree) -> Result<(), LssgError> {
        // save options map after site tree has been created to get all pages
        self.options_map = create_options_map(site_tree)?;
        Ok(())
    }

    fn after_render<'n>(&mut self, document: &mut Document, ctx: &RenderContext<'n>) {
        let site_id = ctx.site_id;
        let body = &document.body;

        let options = self
            .options_map
            .get(&site_id)
            .expect("expected options map to contain all page ids");

        // add breacrumbs if not root
        if ctx.site_id != ctx.site_tree.root() {
            body.prepend(nav::breadcrumbs(document, ctx));
        }

        // move all dom elements to under #content
        let content =
            document.create_element_with_attributes("main", to_attributes([("id", "content")]));
        for child in body.children() {
            child.detach();
            content.append_child(child);
        }
        body.append_child(content);

        if let Some(footer) = options.footer.custom.as_ref() {
            if let Ok(html) = virtual_dom::parse_html_from_string(footer) {
                body.append_child(html);
            }
        } else {
            let mut items = options.footer.items.clone();

            if options.footer.watermark {
                items.push(
                    r#"Generated by <a href="https://github.com/lyr-7D1h/lssg">LSSG</a>"#.into(),
                );
            }

            let mut footer = DomNode::create_element("footer");
            footer.set_attribute("id", "default__footer");
            let mut items = items.into_iter().peekable();
            while let Some(item) = items.next() {
                if let Ok(item) = virtual_dom::parse_html_from_string(&item) {
                    footer.append_child(item);
                }
                if items.peek().is_some() {
                    footer.append_child(" | ");
                }
            }
            body.append_child(footer);
        }

        // Add language to html tag
        if let DomNodeKind::Element { attributes, .. } = &mut *document.root().kind_mut() {
            attributes.insert("lang".to_owned(), options.language.clone());
        }

        // fill head
        head(document, ctx, options);
    }

    fn render_body<'n>(
        &mut self,
        document: &mut Document,
        context: &super::RenderContext<'n>,
        parent: DomNode,
        token: &crate::lmarkdown::Token,
        tr: &mut TokenRenderer,
    ) -> Option<DomNode> {
        match token {
            Token::OrderedList { items, start, .. } => {
                let mut ol = document.create_element("ol");
                if *start != 0 && *start != 1 {
                    ol.set_attribute("start", &start.to_string());
                }
                for tokens in items {
                    let li = document.create_element("li");
                    ol.append_child(li.clone());
                    // don't render paragraphs inside of lists
                    let tokens = tokens
                        .into_iter()
                        .flat_map(|t| {
                            if let Token::Paragraph { tokens, .. } = t {
                                return tokens.clone();
                            }
                            vec![t.clone()]
                        })
                        .collect();
                    tr.render(document, context, li, &tokens);
                }
                parent.append_child(ol);
            }
            Token::BulletList { items, .. } => {
                let ul = document.create_element("ul");
                for tokens in items {
                    let li = document.create_element("li");
                    ul.append_child(li.clone());
                    // don't render paragraphs inside of lists
                    let tokens = tokens
                        .into_iter()
                        .flat_map(|t| {
                            if let Token::Paragraph { tokens, .. } = t {
                                return tokens.clone();
                            }
                            vec![t.clone()]
                        })
                        .collect();
                    tr.render(document, context, li, &tokens);
                }
                parent.append_child(ul);
            }
            Token::Attributes { .. } | Token::Comment { .. } => {}

            Token::ThematicBreak => {
                parent.append_child(document.create_element("hr"));
            }
            Token::Image { tokens, src, title } => {
                let mut resource_id = None;
                // if local page return relative src
                let src = if Input::is_relative(src) {
                    let to_id = context
                        .site_tree
                        .links_from(context.site_id)
                        .into_iter()
                        .find_map(|l| {
                            if let Relation::Discovered { raw_path: path } = &l.relation {
                                if path == src {
                                    return Some(l.to);
                                }
                            }
                            None
                        });

                    if let Some(to_id) = to_id {
                        resource_id = Some(to_id);
                        context.site_tree.path(to_id)
                    } else {
                        warn!("Could not find node where {src:?} points to");
                        src.to_owned()
                    }
                } else {
                    src.to_owned()
                };

                // inject svg into html
                if src.ends_with(".svg") {
                    let readable = if let Some(id) = resource_id {
                        match &context.site_tree[id].kind {
                            SiteNodeKind::Resource(r) => r.readable(),
                            _ => {
                                warn!("svg is not found as a resource");
                                return Some(parent);
                            }
                        }
                    } else {
                        match Input::from_string(&src) {
                            Ok(i) => i.readable(),
                            Err(e) => {
                                error!("failed to get svg: {e}");
                                return Some(parent);
                            }
                        }
                    };

                    match readable {
                        Ok(r) => {
                            // get first valid html tag
                            let mut html = parse_html(r)
                                .unwrap()
                                .into_iter()
                                .find(|e| match e {
                                    Html::Comment { .. } | Html::Text { .. } => false,
                                    Html::Element { .. } => true,
                                })
                                .expect("invalid svg, no html elements founds");

                            match &mut html {
                                Html::Element { attributes, .. } => {
                                    // set viewbox to allow scaling of svg using width and height
                                    if attributes.get("viewbox").is_none() {
                                        let re = Regex::new(r"[0-9]*").unwrap();
                                        let width = if let Some(width) = attributes.get("width") {
                                            re.captures(width)
                                                .map(|c| c[0].to_string())
                                                .unwrap_or(width.clone())
                                        } else {
                                            warn!("no width found for svg, using default of 300");
                                            "300".to_string()
                                        };
                                        let height = if let Some(height) = attributes.get("height")
                                        {
                                            re.captures(height)
                                                .map(|c| c[0].to_string())
                                                .unwrap_or(width.clone())
                                        } else {
                                            warn!("no height found for svg, using default of 150");
                                            "150".to_string()
                                        };
                                        attributes.insert(
                                            "viewbox".into(),
                                            format!("0 0 {width} {height}"),
                                        );
                                    }
                                    attributes.remove(&"style".to_string());
                                    attributes.remove(&"width".to_string());
                                    attributes.remove(&"height".to_string());

                                    parent.append_child(html);
                                    return Some(parent);
                                }
                                _ => error!("svg must be an element"),
                            }
                        }

                        Err(e) => {
                            error!("failed to read {src}: {e}");
                            return Some(parent);
                        }
                    }
                }

                if let Some(format) = SUPPORTED_VIDEO_FORMATS
                    .iter()
                    .find(|format| src.ends_with(&format!(".{format}")))
                {
                    let format = format.to_string();
                    parent.append_child(
                        dom!(<video controls><source src="{src}" type="video/{format}"></video>),
                    );
                    return Some(parent);
                }

                let alt = tokens_to_text(tokens);
                #[allow(unused_variables)]
                if let Some(title) = title {
                    parent.append_child(dom!(<img src="{src}" alt="{alt}" title={title} />))
                } else {
                    parent.append_child(dom!(<img src="{src}" alt="{alt}" />))
                }
            }
            Token::BlockQuote { tokens, .. } => {
                let blockquote = document.create_element("blockquote");
                tr.render(document, context, blockquote.clone(), tokens);
                parent.append_child(blockquote);
            }
            Token::HardBreak { .. } => {
                parent.append_child(document.create_element("br"));
            }
            Token::SoftBreak { .. } => {
                parent.append_child(document.create_text_node(" "));
            }
            Token::Heading { depth, tokens, .. } => {
                let heading = document.create_element(format!("h{depth}"));
                tr.render(document, context, heading.clone(), tokens);
                parent.append_child(heading)
            }
            Token::Paragraph { tokens, .. } => {
                let p = document.create_element("p");
                tr.render(document, context, p.clone(), tokens);
                parent.append_child(p)
            }
            Token::Bold { text } => {
                let b = document.create_element("b");
                b.append_child(document.create_text_node(text));
                parent.append_child(b)
            }
            Token::Emphasis { text } => {
                let e = document.create_element("em");
                e.append_child(document.create_text_node(text));
                parent.append_child(e)
            }
            Token::Code { text: code } => {
                let code_html = document.create_element("code");
                code_html.append_child(document.create_text_node(code));
                parent.append_child(code_html)
            }
            Token::CodeBlock { text: code, info } => {
                let mut code_html = document.create_element("code");
                if let Some(info) = info {
                    code_html.set_attribute("class".into(), &format!("language-{info}"));
                }
                code_html.append_child(document.create_text_node(code));
                let pre = document.create_element("pre");
                pre.append_child(code_html);
                parent.append_child(pre)
            }
            Token::Link {
                tokens,
                href,
                title,
            } => {
                // ignore link if there is no text
                if tokens.len() == 0 {
                    return Some(parent);
                }

                let href = &process_href(href, context);
                // if local page return relative path
                let href = if Page::is_href_to_page(href) {
                    let to_id = context
                        .site_tree
                        .links_from(context.site_id)
                        .into_iter()
                        .find_map(|l| {
                            if let Relation::Discovered { raw_path: path } = &l.relation {
                                if path == href {
                                    return Some(l.to);
                                }
                            }
                            None
                        });

                    if let Some(to_id) = to_id {
                        let rel_path = context.site_tree.path(to_id);
                        rel_path
                    } else {
                        warn!("Could not find node where {href:?} points to");
                        href.to_owned()
                    }
                } else {
                    href.to_owned()
                };

                let mut attributes = to_attributes([("href", href)]);
                if let Some(title) = title {
                    attributes.insert("title".to_owned(), title.to_owned());
                }
                let a = document.create_element_with_attributes("a", attributes);
                tr.render(document, context, a.clone(), tokens);
                parent.append_child(a);
            }
            Token::Text { text } => {
                parent.append_child(document.create_text_node(text));
            }
            Token::Html {
                tag,
                attributes,
                tokens,
            } => {
                if let Some(parent) = render_html::render_html(
                    document, context, &parent, tr, tag, attributes, tokens,
                ) {
                    return Some(parent);
                }
            }
        };
        // always renders
        Some(parent)
    }
}
